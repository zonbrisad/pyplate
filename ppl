#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  [Description]
#    Pyplate help tool. This file is not part of the template itself
#    and shoud be erased when creating a new project based on this
#    template.
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [License]
#     MIT
#
#---------------------------------------------------------------------
# [Bashplates]
# This script is generated from bashplates template generator.
#
# Bashplates is developed by:
# Peter Malmberg <peter.malmberg@gmail.com>
#
# Bashplates is available at:
# https://github.com/zonbrisad/bashplates
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------
bpUserSettings() {
  
  # Settings directory
  MP_CONFIG_DIR=~/.config/pyplate

  # Directory for 3d party files
  #MP_3DPARTY_DIR=${scriptPath}/3dparty

  if [ -e ${BP_DIR}/DEV ]; then
	  DEV=1
	fi
	
	PREAMBLE="#!/usr/bin/env python3"
	TEMPLATES=${BP_DIR}/templates
	HEADER=${TEMPLATES}/header

#  PPL_TEMPLATE_DIR=${BP_DIR}/templates
  PPL_DIR=$(pwd)/pyplate
  PPL_SETTINGS=${PPL_DIR}/pyplate.conf
}
#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------

#
# $1 source file
# $2 destination file
#
bpAppend() { ##I Append file to file
#  if [ ! -f $1 ]; then
#    bpError "Can't append file $( bpColorizeFile ${1}) to $( bpColorizeFile ${2} )."
#  fi
  if cat $1 >> $2 ; then
	  bpOk "$( bpColorizeFile ${1}) appended to $( bpColorizeFile ${2} )."
  else
	  bpError "Can't append file $( bpColorizeFile ${1}) to $( bpColorizeFile ${2} )."
  fi
}
					

##- Create
#
# Create a new script
#
# $1 template file
# $2
# $3 type
#
newScript() {
  t=$3
	name=$(bpRead "Enter name of new ${t}" "")
	
  script="${name}.py"
  									
  if [ -e "${script}" ]; then
    bpError "File ${E_BR_CYAN}${script}${E_END} already exists"
    return
  fi
															
  desc=$(bpRead "Enter description" )
  author=$(bpRead "Enter author" "${BP_NAME} <${BP_EMAIL}>" )
																	
  echo "${PREAMBLE}"            >| ${script}
  echo "$( bpImport $HEADER )"  >> ${script}
	
	if [ -f ${TEMPLATES}/$1 ] ; then
	  bpAppend ${TEMPLATES}/$1   ${script}
	fi
	
  chmod +x ${script}
																									
  bpReplace "${script}" "__NAME__"    "${name}"
  bpReplace "${script}" "__DATE__"    "${BP_DATE}"
  bpReplace "${script}" "__LICENSE__" "${BP_LICENSE}"
  bpReplace "${script}" "__AUTHOR__"  "${author}"
  bpReplace "${script}" "__DESC__"    "${desc}"
																
  bpOk "Created file $script"
}


# createProject() {
#   echo -e ${1}
  
#   pn=$(bpRead "Project name")
#   desc=$(bpRead "Enter script description")
#   author=$(bpRead "Project author" "${BP_NAME} <${BP_EMAIL}>" )

#   bpCp "${2}" ./${pn}.py
  
#   bpReplace ./${pn}.py "__NAME__"    "${pn}"
#   bpReplace ./${pn}.py "__DATE__"    "${BP_DATE}"
#   bpReplace ./${pn}.py "__LICENSE__" "${BP_LICENSE}"
#   bpReplace ./${pn}.py "__AUTHOR__"  "${author}"
#   bpReplace ./${pn}.py "__DESC__"    "${desc}"
#   bpReplace ./${pn}.py "__ORG__"     "${BP_ORG}"
# }

##N- Basic Templates

new() { ##D Create new python file
  #set -o xtrace
  if hasSettings; then
    source ${PPL_SETTINGS}
    ppltemplate.py new --header ${PPL_DIR}/header.txt --author "${PPL_NAME}" --email "${PPL_EMAIL}"
    return 0
  fi

  if [ -n BP_NAME ]; then
    ppltemplate.py new --author "${BP_NAME}" --email "${BP_EMAIL}"
    return 0
  fi

  ppltemplate.py new ${ARGS} 
}

newa() { ##D Create new terminal application
  if hasSettings; then
    source ${PPL_SETTINGS}
    ppltemplate.py newa ${ARGS} --header ${PPL_DIR}/header.txt --author "${PPL_NAME}" --email "${PPL_EMAIL}"
  else
    ppltemplate.py newa ${ARGS} 
  fi
}

newm() { ##D Create new minimal python file
  if hasSettings; then
    source ${PPL_SETTINGS}
    ppltemplate.py newm ${ARGS} --header ${PPL_DIR}/header.txt --author "${PPL_NAME}" --email "${PPL_EMAIL}"
  else
    ppltemplate.py newm ${ARGS} 
  fi
}

##- Header
hasSettings() {
  if [ -d ${PPL_DIR} ]; then
    return 0
  else
    return 1
  fi
}

bpVarExist() {
  if [ -n "$1" ]; then
    return 0
  else
    return 1
  fi
}

bpDefault() { ##D 
  if bpVarExist "$1"; then
    return $$1
  fi
}

cls() { ##D Create a local settings 

  if hasSettings ; then
    bpInfo "Settings already exists"
    return
  fi

  if ! bpMkDir ${PPL_DIR}; then
    bpError "Failed to create local pyplate settings"
    return
  fi

  ppltemplate.py --printheader >| ${PPL_DIR}/header.txt

  # If Bashplate settings are avalable use as default values
  if [ -n "BP_NAME" ]; then
    DEFAULT_NAME="${BP_NAME}"
  else
    DEFAULT_NAME=""
  fi
  
  if bpVarExist "BP_EMAIL"; then
    DEFAULT_EMAIL="${BP_EMAIL}"
  else
    DEFAULT_EMAIL=""
  fi

  bpAddSetting  $PPL_SETTINGS "PPL_NAME" "$(bpRead "Enter name" "${DEFAULT_NAME}" ) " "Name of creator"
  bpAddSetting  $PPL_SETTINGS "PPL_EMAIL" "$(bpRead "Enter email" "${DEFAULT_EMAIL}" )" "Email of creator"
  bpAddSetting  $PPL_SETTINGS "PPL_PROJECT" "$(bpRead "Enter project name")" "Project name"
  bpAddSetting  $PPL_SETTINGS "PPL_DESCRIPTION" "$(bpRead "Enter project description")" "Project description"
  bpAddSetting  $PPL_SETTINGS "PPL_LICENSE" "$(bpRead "Enter license")" "Default license"
}

##C- DEV GUI Templates

newqt() { ##C DEV Create new QT5 python project 
  createProject "Creating new Qt5 python project" ${BP_DIR}/pyplate-qt5.py
}

newgtk() { ##C DEV Create new GTK python project
  :
}

##C- DEV Template edit

eb() { ##C DEV Edit basic template
  bpEdit ${TEMPLATES}/basic.py
}

ec() { ##C DEV Edit cli template
  bpEdit ${TEMPLATES}/cli.py
}
 
eh() { ##C DEV Edit header
  bpEdit ${TEMPLATES}/header
}


##C- DEV Setup

install() { ##C DEV Install init module
  bpAddModule ${BP_DIR}/pypl_init
}

##C- DEV Project management (git)

clean() { ##C DEV Remove leftover files 
  bpCd "${BP_DIR}"

  find . -name "*~"     -delete
  find . -name "*.orig" -delete

  # Remove untraced files
  git clean -df -e *.log
  bpCd -
}

commit() { ##C DEV Commit project to repository
  bpCd "${BP_DIR}"
  git commit -a
  #git push --tags -a
  bpCd - 
}

tag() { ##C DEV Make a new tag
  bpCd "${BP_DIR}"
  # List existing tags
  git tag

  # read tag name/description
  tag=$( bpRead "Tagname" "")
  desc=$( bpRead "Description" "")

  # Tag revision
  git tag -a "$tag" -m "$desc"
  bpCd - 
}

push() { ##C DEV Push project to GITHUB
  bpCd "${BP_DIR}"
  git push --progress
  bpCd - 
} 

pull() { ##C DEV Pull project from GITHUB
  bpCd "${BP_DIR}"
  git pull --progress
  bpCd - 
} 

#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------
bpInitSettings() { 

##V Script version info
BP_VERSION="1.03"

##V Usage info
BP_USAGE="Usage: ${BP_NAME} command [option]"

##V Description text
BP_DESC="Help tool for pyplate project"

##V logfile (uncomment to use logfile)
BP_LOGFILE=${BP_DIR}/${BP_NAME}.log

##V Lock file (uncomment to use lock file feature )
#BP_LOCK_FILE=/tmp/${BP_NAME}.lock

##V Logging options (uncomment to activate logging parameters)
BP_LOG_OK=1
BP_LOG_INFO=1
BP_LOG_WARNING=1
BP_LOG_ERROR=1
BP_LOG_CRITICAL=1

##V Activate settings function (will create settings file when run)
BP__CONF=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULT_CMD_HOOK=help

##V Pre script hook, execute this function before every command
#PRE_SCRIPT_HOOK=

##V Post script hook, execute this function after every command
#POST_SCRIPT_HOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRE_CMD_HOOK=

##V Function to be executed after every other function except DEFAULT function
#POST_CMD_HOOK=

##V Function to be executed after information command
#POST_INFO_HOOK=

##V Function run before help command is executed
#PRE_HELP_HOOK=

##V Function run after help command is executed
#POST_HELP_HOOK=

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_E_OK"
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

signalErr() {
  echo
  echo
  bpError "Trace error Row: $2  Function: $1"
  echo
  bpCallStack
  bpExit 1
}

signalDbg() {
  echo "Debug Row: $2  Function: $1"
}

##C- IHELP Exit and cleanup

bpCallStack() { ##I Print out BASH call stack
  bpTextLine "Call stack"
  echo
  local frame=0
  while caller $frame | sed -r -e "s/[0-9]*/${BP_C_VALUE}&${E_END}/"   ; do
    ((frame++));
  done
  echo "$*"
  bpLine
}

bpCleanUp() { ##I Cleanup function
  rm -f "$BP_LOCK_FILE"    # remove Lock file
#  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##I Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  if [ -n "$POST_SCRIPT_HOOK" ]; then
     ${POST_SCRIPT_HOOK}
  fi

  # Check if argument is given
  if [ -z "$1" ]; then
    exit 0   # Success
  else
    exit "$1"
  fi

}

bpErrorExit() {  ##I Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# Terminal codes
#---------------------------------------------------------------------

# ANSI foreground colors codes
#
E_BLACK=$'\e[0;30m'        # Black
E_RED=$'\e[0;31m'          # Red
E_GREEN=$'\e[0;32m'        # Green
E_YELLOW=$'\e[0;33m'       # Yellow
E_BLUE=$'\e[0;34m'         # Blue
E_MAGENTA=$'\e[0;35m'      # Magenta
E_CYAN=$'\e[0;36m'         # Cyan
E_GRAY=$'\e[0;37m'         # Gray
E_DARKGRAY=$'\e[1;30m'     # Dark Gray
E_BR_RED=$'\e[1;31m'       # Bright Red
E_BR_GREEN=$'\e[1;32m'     # Bright Green
E_BR_YELLOW=$'\e[1;33m'    # Bright Yellow
E_BR_BLUE=$'\e[1;34m'      # Bright Blue
E_BR_MAGENTA=$'\e[1;35m'   # Bright Magenta
E_BR_CYAN=$'\e[1;36m'      # Bright Cyan
E_WHITE=$'\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK=$'\e[40m'       # Black
E_ON_RED=$'\e[41m'         # Red
E_ON_GREEN=$'\e[42m'       # Green
E_ON_YELLOW=$'\e[43m'      # Yellow
E_ON_BLUE=$'\e[44m'        # Blue
E_ON_MAGENTA=$'\e[45m'     # Magenta
E_ON_CYAN=$'\e[46m'        # Cyan
E_ON_WHITE=$'\e[47m'       # White

# ANSI Text attributes
E_ATTR_BOLD=$'\e[1m'
E_ATTR_LOWI=$'\e[2m'
E_ATTR_UNDERLINE=$'\e[4m'
E_ATTR_BLINK=$'\e[5m'
E_ATTR_REVERSE=$'\e[7m'

# ANSI cursor operations
#
E_RETURN=$'\e[F'           # Move cursor to begining of line
E_UP=$'\e[A'               # Move cursor one line up
E_DOWN=$'\e[B'             # Move cursor one line down
E_FORWARD=$'\e[C'          # Move cursor forward
E_BACK=$'\e[D'             # Move cursor backward
E_HIDE=$'\e[?25l'          # Hide cursor
E_SHOW=$'\e[?25h'          # Show cursor

E_END=$'\e[m'              # Clear Attributes

# Default Bashplate colortheme
BP_C_OK=$E_BR_GREEN
BP_C_INFO=$E_BR_CYAN
BP_C_WARNING=$E_BR_YELLOW
BP_C_ERROR=$E_BR_RED
BP_C_CRITICAL=$E_ON_RED$E_WHITE
BP_C_LINE=$E_DARKGRAY
BP_C_LINE_TEXT=$E_YELLOW
BP_C_DESCRIPTION=$E_GREEN
BP_C_ID=$E_CYAN
BP_C_FILENAME=$E_BR_GREEN
BP_C_PATH=$E_GREEN

# Shellscript colorize colors
BP_C_RESERVED=$E_RED
BP_C_COMMENT=$E_CYAN
BP_C_STRING=$E_GREEN
BP_C_VAR=$E_BR_YELLOW

# Exit codes
#
BP_E_OK=0            # successful termination

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------

##C- IHELP Printing functions

#
# arg1 text to be printed
# arg2 text color
# arg3 line color
# arg4 middle character
# arg5 line character
#
bpPrintLineC() { ##I Print text with adjusted line after with selectable colors
  len1="${#1}"
  len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  l=$(( BP_COLUMNS - len1 - len4  ))
  seq -s"${5}" "${l}"|tr -d '[:digit:]'
  echo -en ${E_END} 
}

#
# arg1 text to be printed
# arg2 text color
# arg3 line color
#
bpTextLineC() { ##I Print text with adjusted line after with selectable colors
  bpPrintLineC "$1" "$2" "$3" " " "-"
}

bpTextLine_old() { ##I Print text with line after
  bpTextLineC "$1" "${BP_C_LINE_TEXT}" "${BP_C_LINE}"
}

bpTextLine() { ##I Print text with line after
#  echo "$1 ${#1}"
  if [ "${#1}" -eq 0 ]; then
	  bpPrintLineC "" "" "${BP_C_LINE}" "" "-"
	else
  	bpPrintLineC "$1" "${BP_C_LINE_TEXT}" "${BP_C_LINE}" " " "-"
	fi
}


bpLine() { ##I Print a divider row
  bpPrintLineC "" "${BP_C_LINE}" "${BP_C_LINE}" "" "-"
}


# 
# $1 command color
# $2 description color
# $3 command text
# $4 desccription text
#
bpPrintInfoGeneric() { # Generic command/description printout function
  printf "${1}  %-24.24s${E_END} ${2}%s${E_END}\n" "$3" "$4"
}

#
# arg1 text for column 1
# arg2 text for column 2
#
bpPrintInfo() { ##I Print text into two columns
  bpPrintInfoGeneric "${BP_C_ID}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

bpPrintInfoAlt() {
  bpPrintInfoGeneric "${E_DARKGRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

#
# $1 text for column 1
# $2 variable for column 2
# $3 optional text form column 2
#
bpPrintVar() { ##I Print variable value and description
  var="$2"      
  if [ "${!var}" ]; then
    if [ ! -z "$3" ]; then
      X=${3}
    else 
      X="${!var}"
    fi
    bpPrintInfo "$1" "${X}"
  else
    printf "${BP_C_ID}  %-24s${E_END} ${E_RED}N/A${E_END}\n" "$1"
  fi
}


#
# Colorize string containing filename
#
# $1 string with filename to colorize
# ret colorized string
#
bpColorizeFile() { ##I Colorize string containing filename
  if [ ! -z "$1" ]; then
    echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_END}"
  fi
}

#
# $1 string with url to colorize
# ret colorized string
#
# todo: give username own color
#
bpColorizeUrl() { ##I Colorize string containing URL
  url=$(echo -n $1 | sed -r -e "s/^.*\/\///")
  prot=$(echo -n $1 | sed -r -e "s/:\/.*//")
  #un=$( echo $url | sed -r -e 's/\(.*\)@/$1/')
  #echo "UN: ${un}"
  echo -e -n "${E_DARKGRAY}${prot}${E_END}://$(bpColorizeFile ${url})"
}

#
# $1 string to be filtered
#
bpFilterEscape() { ##I Filter escape characters from string
  echo "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}
  

##C- IHELP File operations

#
# $1 command to execute
#
bpRun() { ##I Execute command
  if [ -e "$1" ]; then
    ${1}
  else
    bpError "Could not execute $1, file does not exist!"
  fi
}

#
# $1 directory to change to
#
bpCd() { ##I Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

#
# $1 Directory to be created
#
bpMkDir() { ##I Create a directory if it does not exist
  if [ ! -d "$1" ]; then
    if mkdir -p "$1"; then
      bpOk "Creating directory $( bpColorizeFile ${1} )."
      return 0
    else
      bpError "Failed to create directory $( bpColorizeFile ${1} )."
      return 1
    fi
  fi
}

#
# $1 target file/dir
# $2 link
#
bpLn() { ##I Create symbolic link
  if [ ! -L "$1" ]; then
    if ln -sf "${1}" "${2}" ; then
      bpOk "Creating link $( bpColorizeFile ${2} )."
      return 0
    else
      bpError "Failed to create link $( bpColorizeFile ${2} )."
      return 1
    fi
  fi
}

# 
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##I Copy file(s)
  if cp -rf "$@" ; then
    bpOk "Copying $( bpColorizeFile ${1} ) to $( bpColorizeFile ${2} )"
    return 0
  else
    bpError "Failed copying $( bpColorizeFile ${1} ) to $( bpColorizeFile ${2} )"
    return 1
  fi
}

#
# $1 file(s) to be moved
# $2 destination
#
bpMv() { ##I Move file(s)
  if mv "$1" "$2" ; then
    bpOk "Moving file $( bpColorizeFile ${1} ) to $( bpColorizeFile ${2})."
    return 0
  else
    bpError "Failed moving file $( bpColorizeFile ${1} ) to $( bpColorizeFile ${2})."
    return 1
  fi
}

# 
# $1 file(s) to be removed
#
bpRm() { ##I Remove file(s)
  if rm -rf "${1}" ; then
    bpOk "Removing file $( bpColorizeFile ${1} )."
    return 0
  else
    bpError "Failed removing file $( bpColorizeFile ${1} )."
    return 1
  fi
}


#
# $1 file to be backed up
#
bpBackup() { ##I Make backup of file
  BF="${1}_$(date +"%Y%m%d")-$(date +"%H%M%S").bak"

  if cp -rf "$1" "${BF}" ; then
    bpOk "Backing up file $( bpColorizeFile $1 ) to $( bpColorizeFile ${BF} )."
    return 0
  else
    bpError "Failed backing up file $( bpColorizeFile $1 ) to $( bpColorizeFile ${BF} )."
    return 1
  fi
}

#
# $1 file 
# $2 text to replace
# $3 new text
#
bpReplace() {  ##I Replace text in file
  sed -i -e "s/${2}/${3}/g"  "$1"
}

#
# $1 file 
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() {  ##I Replace entire line matching pattern
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##I Append a line if it does not exist in file
  grep -q -F "$2" "$1" || echo "$2" >> "$1"
}

#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##I Remove line in file if it contains given string
  grep -v "$2" "$1" > "${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# $1 file
# $2 string
# return true if existing 
#
bpStrExist() { ##I Check if string exist in file  
  if [ ! -f $1 ]; then
    return 1
  fi

  if grep -q -F "$2" "$1" ; then
    return 0
  else
    return 1
  fi
}

#
# $1 file to open in editor
#
bpEdit() { ##I Open file in default editor (BP_EDIT variable must be set)
  if [ -n "$BP_EDITOR" ]; then
    ${BP_EDITOR} "${1}"
  else
    bpError "BP_EDITOR variable not set, can't open file ${1}"
  fi
}

# 
# $1 file
# $2 start marker
# $3 end marker
#
bpGetSection() { ##I Get text from file between two markers
  cat "$1" | grep -A 10000 -m 1 "$2" | grep -B 10000 -m 1 "$3" | grep -v "$2" | grep -v "$3"
}


# 
# $1 File to import
#
bpImport() { ## Import file into variable
  if [ -f $1 ]; then
	  cat $1
	fi
}

#
# $1 file
# $2 match
# $3 text to insert
#
bpInsert() { ##I Insert text into file
	a=$( cat "$1" | grep -A 10000 "$2" | grep -v "$2" )
	b=$( cat "$1" | grep -B 10000 "$2" | grep -v "$2" )
 
  echo "$b" "$3" "$a"  >| $1
}



##C- IHELP Input

#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpRead() { ##I Read string from commandline

  if [ "${2}" == "" ]; then
    read -erp "${1} >" result
  else
    read -erp "${1} [$2] >" result
    if [ "${result}" == "" ]; then
      result="${2}"
    fi
  fi

  echo "${result}"
}

#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##I Read integer from commandline
  while true; do
    if [ "${2}" == "" ]; then
      read -erp "${1} ($3-$4) >" result
      if [ "${result}" == "" ]; then
        result=$(($3 - 1))
      fi
    else
      read -erp "${1} ($3-$4) [$2] >" result
      if [ "${result}" == "" ]; then
        result="${2}"
      fi
    fi
    if [ $((result)) -ge "$3" ] && [ $((result)) -le "$4" ]; then
      break
    fi
  done
  echo "${result}"
}


#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadYN() {  ##I Ask yes/no question generic 
  while true; do
  
    if [ "$2" -eq 1 ]; then 
      yn=$( bpRead "${1} [y/N]" )      
    else
      yn=$( bpRead "${1} [Y/n]" )
    fi
  
    case "$yn" in
      [Yy]* ) return 0;  break;;
      [Nn]* ) return 1;  break;;
      ""    ) return "$2"; break;;
      * ) echo "Please answer yes or no.";;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadY() { ##I Ask yes/no question default yes
  bpReadYN "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadN() { ##I Ask yes/no question default no
  bpReadYN "$1" 1
  return $?
}


#---------------------------------------------------------------------
#
#---------------------------------------------------------------------

# Settings file ------------------------------------------------------

##C- BP_CONF Bashplate settings

#
# arg1 config file
# arg2 setting name
# arg3 setting value
# arg4 setting description
#
bpAddSetting() { 

  # Check if setting exist in file
  #S=$(bpStrExist "${1}" "${2}" )

  #if [ "${S}" == "0" ]; then
  if ! bpStrExist "${1}" "${2}"; then
    {
      echo "# ${4}" 
      echo "${2}=\"${3}\"" 
      echo 
    } >> "${1}"
  fi
}

bpAddSettings() {
  bpAddSetting $BP_SETTINGS "BP_NAME"    "John Doe"          "Name of user"
  bpAddSetting $BP_SETTINGS "BP_EMAIL"   "JohnDoe@foo.bar"   "Email of user"
  bpAddSetting $BP_SETTINGS "BP_EDITOR"  "vi"                "Default editor"
  bpAddSetting $BP_SETTINGS "BP_LICENSE" "MIT"               "Default project license"
  bpAddSetting $BP_SETTINGS "BP_ORG"     "ACME"              "Default organisation"
  bpAddSetting $BP_SETTINGS "BP_DIFF"    "meld"              "Default diff program"	
  bpAddSetting $BP_SETTINGS "BP_PATH"    "${BP_DIR}" "Path to Bashplates directory"
}

# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
bpChSetting() {  
  SETTING="$2"
  VAL="$3"
  
  S=$(bpStrExist "${1}" "${2}" )
  if [ "${S}" == "0" ]; then
    bpAddSettings
  fi
  sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" "$1"
	
  bpInfo "Setting ${SETTING} to ${VAL}"
}

bpCreateSettings() {
  bpInfo "Creating new bashplates settings. $( bpColorizeFile ${BP_SETTINGS} )"
  bpMkDir "${BP_SETTINGS_DIR}"
  bpMkDir "${BP_SETTINGS_PATHS}"
  bpMkDir "${BP_SETTINGS_MODULES}"
  
  # if file does not exist add header
  if [ ! -e ${BP_SETTINGS} ]; then
    echo "# " >> ${BP_SETTINGS}
    echo "# Bashplates common settings" > ${BP_SETTINGS}
    echo "# " >> ${BP_SETTINGS}
    echo      >> ${BP_SETTINGS}
  fi
  bpAddSettings
}

bpLoadSettings() {
  if [ -n "${BP_SETTINGS}" ]; then
    if [ -e "${BP_SETTINGS}" ]; then
      source "${BP_SETTINGS}"
    else
      bpCreateSettings
      source "${BP_SETTINGS}"
    fi
  fi
}

settings() { ##C BP_CONF Print bashplate settings
  bpTextLine "Bashplates settings"
  bpPrintVar "Name:"                BP_NAME 
  bpPrintVar "Email:"               BP_EMAIL
  bpPrintVar "Default license:"     BP_LICENSE
  bpPrintVar "Default editor"       BP_EDITOR
  bpPrintVar "Default organisation" BP_ORG
  bpPrintVar "Default diff program" BP_DIFF
  bpLine
}

setname() { ##C BP_CONF Set name
  bpChSetting "${BP_SETTINGS}" "BP_NAME" "\"${2}\""
}

setemail() { ##C BP_CONF Set email address
  bpChSetting "${BP_SETTINGS}" "BP_EMAIL" "\"${2}\""  
}

seteditor() { ##C BP_CONF Set default editor
  bpChSetting "${BP_SETTINGS}" "BP_EDITOR" "\"${2}\""  
}

setlic() { ##C BP_CONF Set default license
  bpChSetting "${BP_SETTINGS}" "BP_LICENSE" "\"${2}\""  
}

setorg() { ##C BP_CONF Set default organisation
  bpChSetting "${BP_SETTINGS}" "BP_ORG" "\"${2}\""  
}

setdiff() { ##C BP_CONF Set default diff program
  bpChSetting "${BP_SETTINGS}" "BP_DIFF" "\"${2}\""  
}

##C- IHELP Bashrc path/module handling

bpLsPaths() { ##I List paths
  for p in ${BP_SETTINGS_PATHS}/*; do
    echo  "A: $( readlink ${p} )"
  done
}

#
# $1 directory to add to path
#
bpAddPath() { ##I Add dir to PATH variable
  ll=$( echo "${1}" | sed -e 's/\//_/g' )

  bpInfo "Adding PATH \"${2}\""
  if [ ! -L "$1" ]; then
     bpLn  "${1}" "${BP_SETTINGS_PATHS}/${ll}"
  fi
}

bpRmPath() { ##I Remove path
  bpRm "${BP_SETTINGS_PATHS}/${1}"
}

bpLsModules() { ##I List modules
  for p in ${BP_SETTINGS_MODULES}/*; do
    echo  "A: $( readlink ${p} )"
  done
}

bpAddModule() { ##I Add init script to
  m=$( realpath "${1}" )
  if [ ! -L "$m" ]; then
    rm -f "${BP_SETTINGS_MODULES}/$(basename $m)"
    bpLn "$m" "${BP_SETTINGS_MODULES}/."
  fi
}

bpRmModule() { ##I Remove module
  bpRm "${BP_SETTINGS_MODULES}/${1}"
}


##-

# Logging ---------------------------------------------------------

##C- IHELP Log functions

#
# Function logging to file
#
# Arg1 String to log to file
#
bpLog() { ##I Log to file command
  # check for BP_LOGFILE variable
  if [ -n "$BP_LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1"  >> "${BP_LOGFILE}"
  fi
}

bpLogOk() { ##I Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() {  ##I Log Info message to file
  bpLog "[Info] $1"
}

bpLogWarning() {  ##I Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() {  ##I Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() {  ##I Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C BP_LOGFILE View logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then  # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < "${BP_LOGFILE}" )

      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() {   ##C BP_LOGFILE Monitor logfile
  if [ -n "$BP_LOGFILE" ]; then
    if [ -f "${BP_LOGFILE}" ]; then  # Check that logfile exists
      tail -f "${BP_LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|"

    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##C- IHELP Message

bpOk() { ##I Success message
  if [ -n "$BP_LOG_OK" ]; then
    bpLogOk "$1"
  fi  
  echo -e "[${BP_C_OK}Ok${E_END}] $1"
}

bpInfo() { ##I Info message
  if [ -n "$BP_LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_END}] $1"
}

bpWarning() { ##I Warning message
  if [ -n "$BP_LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_END}] $1"
}

bpError() { ##I Error message
  if [ -n "$BP_LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_END}] $1"
}

bpCritical() { ##I Critical error message
  if [ -n "$BP_LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_END}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##C- IHELP Assert

bpAssertRoot() { ##I Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##I Assert that lockfile is not present
  if [ -n "$BP_LOCK_FILE" ]; then
    if [ -f "$BP_LOCK_FILE" ]; then
      bpError "Script is already running. (${BP_LOCK_FILE})"
      exit  "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$BP_LOCK_FILE"
  fi
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##I Assert that required programs are available on the system
  things=("$@")
  e=0
  for thing in "${things[@]}" ;do
    hash "$thing" 2>&- || \
      { bpError "Required program \"$thing\" not found."; e=1; }
  done
  if [ $e -eq 1 ]; then
    bpExit 1
  fi
}

##C- IHELP Debug/Controll

icheck() { ##I Make a shellcheck
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##I Remove tabs from script
  sed -i -e 's/\t/  /g' "${BP_DIR}/${BP_NAME}"
}

##C- IHELP Help & info

printCommand() {
  help_line=$1
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$2"'//')
  bpPrintInfo "$help_command" "$help_info"
}

printCondCommand() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##C//' | awk '{print $1}')
  
  eval "D=\$$C"
  
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$C"'//')

  if [ -n "$D" ]; then
    bpPrintInfo "$help_command" "$help_info"
  else
    if [ "$2" -eq 1 ]; then
      bpPrintInfoAlt "$help_command" "$help_info"
    fi
  fi
}

printNamedLine() {
  name=$(echo "$1" | sed -e 's/^.*##-//' -e 's/^[ \t]*//' )
  bpTextLine "$name"
}

printCondNamedLine() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##C-//' | awk '{print $1}')
  name=$(echo "$help_line" | sed -e 's/^.*'"$C"'//' -e 's/^[ \t]*//' )
  eval "D=\$$C"
  if [ -n "$D" ]; then
    bpTextLine "$name"
  fi
}

help() { ##D Print help information
  echo "$BP_USAGE"
  echo -e "$BP_DESC"
  echo 
	
  BP_HELP=1
	
  if [ ! -e "${BP_SETTINGS_DIR}" ] && [ -n "${BP_SETTINGS}" ]; then
    BPINIT=1	
  fi
	
 # bpExecHook "PRE_HELP_HOOK"
  if [ -n "$PRE_HELP_HOOK" ]; then
    "${PRE_HELP_HOOK}" 
  fi

  IFS=$'\n'
  SC="$1"
  help_lines=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##I' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##-//' -e 'help_line' -e 'printLine')
  for help_line in ${help_lines} ; do
    case "$help_line" in
      *"##-"*)   printNamedLine     "$help_line" ;;
      *"##C-"*)  printCondNamedLine "$help_line" ;;
      *"##CV"*)  printCondCommand  "$help_line" 1 ;;
      *"##C"*)   printCondCommand  "$help_line" 0 ;;
      *"##D"*)   printCommand       "$help_line" '##D' ;;
      *)
      ;;
    esac
  done

  if [ -n "$POST_HELP_HOOK" ]; then
    "${POST_HELP_HOOK}" 
  fi
}

#
# $1 command
# 
ihelp() { ##I Print internal help information  

  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpTextLine "$2"
    echo
    echo "#"
    echo -n "# "
    grep --no-filename "$0" -e "${2}()"  | sed -n -e 's/^.*##I //p' 
    grep --no-filename -B 8 "$0" -e "${2}()" | grep "#" | grep -v "##"
    bpLine
    bpExit
  fi

  IFS=$'\n'
  SC="$1"

  IHELP=1    # Force ihelp documentations
  BP_LOGFILE=1  # Force log documentation

  help_lines=$(grep -h '##[C|I|-]' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'help_line' -e 'printNamedLine' -e 'awk' -e 'bpPrintInfo' -e 'name' )
  for help_line in ${help_lines} ; do
    case "$help_line" in
      *"##-"*)   printNamedLine     "$help_line" ;;
      *"##C-"*)  printCondNamedLine "$help_line" ;; 
      *"##I"*)   printCommand       "$help_line" '##I' ;;
      *"##C"*)   printCondCommand   "$help_line" 0 ;;
      *)
      ;;
    esac
  done

  bpTextLine "Bashplates comments"
  bpPrintInfo "##D Description"      "Subcommand information comment (shown with help)"
  bpPrintInfo "##C COND Description" "Conditional subcommand comment (shown with help)"
  bpPrintInfo "##- [Text]"           "Separator line (shown with help)"
  bpPrintInfo "##C- COND [Text]"     "Conditional separator line (shown with help)"
  bpPrintInfo "##I Description"      "Internal function comment (shown ihelp)"
  bpLine
}

iinfo() { ##I Show information about script
  bpTextLine "Script information"
  bpPrintVar "Script" BP_NAME "$( bpColorizeFile "${BP_DIR}/${BP_NAME}" )"
  bpPrintVar "Script version" BP_VERSION
  bpPrintVar "Template version" BP_VERSION 
  bpPrintVar "Bashplate settings file" BP_SETTINGS "$( bpColorizeFile ${BP_SETTINGS} )"
  bpPrintVar "Log file" BP_LOGFILE  "$( bpColorizeFile "${BP_LOGFILE}" )"
  bpPrintVar "Lock file"  BP_LOCK_FILE  "$( bpColorizeFile "${BP_LOCK_FILE}" )"
  bpPrintVar "Default function" DEFAULT_CMD_HOOK
  bpPrintInfo "PID"  $$   
  bpPrintVar "Date" BP_DATE
  bpPrintVar "Time" BP_TIME
  bpPrintVar "Character columns" BP_COLUMNS 
  bpPrintVar "Character lines" BP_LINES

  if [ -n "${POST_INFO_HOOK}" ]; then
    bpTextLine "App. information"
    ${POST_INFO_HOOK}
  fi
  settings
}

#
iview() {  ##I View example
  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpTextLine "$2"
    echo
    grep --no-filename -A 60  "$0" -e "${2}()" | grep -B 60 -m 1 -x "}" | \
      sed  -e "s/#.*/\\${BP_C_COMMENT}&\\${E_END}/"          \
             -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_END}/"     \
             -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_END}/"   \
             -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<break\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\".*\"/\\${BP_C_STRING}&\\${E_END}/"        \
             -e "s/\([^=]*\)=/${BP_C_VAR}\1\\${E_END}=/"        \
#             -e $VF
#             -e 's/\$[{]?[a-zA-Z0-9]*[}]?/XXX/'
#             -e 's/$?/'"\\${BP_C_VAR}&\\${E_END}/" \
    bpLine
    bpExit
  fi
}

ivars() { ##I Print internal variables
  bpTextLine "Script variables"
  echo
  IFS=$'\n'
  help_lines=$( grep -v -e 'help_lines' -e 'help_line' "$0" | grep -A 1 '##V'   ) # | sed "s/--//" )
  for line in ${help_lines}; do
    if [ "$line" == "--" ]; then
      echo
    else
      help_line=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_ID}&${E_END}/i" -e "s/=/${E_END}=/" )
      echo -e "$help_line"
      echo -en "$E_END"
  fi
  done
  echo
}

ied() { ##I Open this file with standard editor
  bpEdit $0
}


version() { ##D Print version information
  echo "$BP_VERSION"
}

# Runs a function in this file as a command
bpRunCommand() {
  if [ "$BP_ARGUMENTS" -eq 0 ]; then

    # check for a default command
    if [ -n "$DEFAULT_CMD_HOOK" ]; then
      "$DEFAULT_CMD_HOOK" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi

  if [ "$( type -t $1 )" = "function" ]; then # Check if subcommand is declared as function
      command=$1
      # execute pre command hook  if existing
      if [ -n "$PRE_CMD_HOOK" ]; then
        "${PRE_CMD_HOOK}" "$command"
      fi

      # Check if command is conditional
      if [[ $( grep "${command}()" "$0" ) = *"##C"* ]]; then  

        # Check if condition is true and then execute else printout error message
        C=$( grep "${command}()" "$0"  | sed -s 's/^.*##C.//' | awk '{print $1}' )
        if [ -n "$C" ]; then
          eval "D=\$$C"

          if [ -n "$D" ]; then
            # execute command
            "${command}" "$@" 
          else
            bpError "Command \"$command\" not available right now."
          fi
        else
          bpError "Command \"$command\" is conditional, but is missing conditional variable"
        fi
      else 
        # command is not conditional, execute
        "${command}" "$@"
      fi

      # execute post command hook  if existing
      if [ -n "$POST_CMD_HOOK" ]; then
        "${POST_CMD_HOOK}" "$command"
      fi      
      bpExit
  else
    bpErrorExit "Command \"$1\" not found"
  fi
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Bashplate version
BP_VERSION="1.20"

##V Directory where script is located
BP_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

##V Name of script
BP_NAME=$(basename "$0")

##V Number of arguments given to script
BP_ARGUMENTS=$#

##V Current date
BP_DATE=$(date +"%Y-%m-%d")

##V Current time
BP_TIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BP_COLUMNS=$(tput cols)

##V Number of lines in terminal
BP_LINES=$(tput lines)

##V Settings directory
BP_SETTINGS_DIR=~/.config/bashplates

##V Settings file
BP_SETTINGS=${BP_SETTINGS_DIR}/bashplates.conf

##V System Path's
BP_SETTINGS_PATHS="${BP_SETTINGS_DIR}/path"

##V Links to modules
BP_SETTINGS_MODULES="${BP_SETTINGS_DIR}/modules"

# Initiate bashplate settings
bpInitSettings

# Initiate user settings
bpUserSettings

#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap  signalQuit SIGQUIT
trap  signalInt  SIGINT
trap  signalHup  SIGHUP
trap  signalTerm SIGTERM
trap  'signalErr ${FUNCNAME} ${LINENO}' ERR

#trap  'signalDbg ${FUNCNAME} ${LINENO}' DEBUG

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

# Load configuration file settings
bpLoadSettings

# execute prescript hook if existing
if [ -n "$PRE_SCRIPT_HOOK" ]; then
  ${PRE_SCRIPT_HOOK} "$@"
fi

#xx() {

# OPTS=$(getopt --longoptions idebug -- "$@")
# echo $OPTS
# eval set --$OPTS

# while true; do
#   case "$1" in
#     --idebug)
#       set -o xtrace
#         ;;
#     --)
#         shift
#         break
#         ;;
#     esac
#     shift
# done
#}
#echo $@
#xx

# Run command parser
bpRunCommand "$@"

# Exit cleanly
bpExit

##C- BP_HELP
